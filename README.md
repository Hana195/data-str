# 김 은우
### 202530207

## 11월 13일 강의

### 선형 리스트
  * **리스트 list**
    * 데이터를 순서대호 나열해 놓은 자료구조
    * 가장 단순한 구조를 가진 리스트를 선형 리스트 또는 연결 리스트라고 함
    * 건너뛰어 데이터를 전달할 수 없음
  
  * **노드(node)**
    * 리스트의 각 요소
    * 각각의 노드는 데이터와 다음 노드를 가리키는 포인터를 가짐
    * 처음과 끝의 노드는 각각 머리 노드, 꼬리 노드라 표현
    * 하나ㅡ이 노드에 대해 바로 앞에 노드를 앞쪽 노드, 바로 뒤에 노드를 다음 노드라 함
  
    * **다음 노드 꺼내기**
      * 배열의 각 요소에는 순서대로 데이터가 저장
      * 다음 노드 꺼내기는 1만큼 큰 인덱스를 갖는 요소에 접근
  
    * **노드의 삽입과 삭제**
      * 삽입,삭제하는 경우 모든 요소를 밀거나 앞으로 당겨야 함
      * 배열로 구현한 선형 리스트는 데이터의 크기를 미리 알아야함
      * 데이터를 모두 옮겨야 하기 때문에 효율이 좋지 않음
  
  * **노드용 구조체 Node**
    * 연결 리스트에 데이터를 삽입할 때 만들고 삭제할 때 없애면 데이터를 밀고 당기는 문제 해결 가능
    * 두 멤버 data와 next로 구성
      * data: 데이터
      * next: 다음 노드에 대한 포인터
    * 자기 자신과 같은 자료형의 댇체를 가리키는 데이터가 내부에 포함
    * 이러한 자료구조를 **자기 참조형**이라고 함
     
  * **연결 리스트를 관리하는 구조체 List**
    * 노드형 구조체를 사용한 연결 리스트
    * 두 멤버로 구성되어 있고 Node에 대한 포인터 자료형을 가짐
    * head는 연결 리스트의 머리 노드를 가리키는 머리 포인터이고, crnt는 현재 선택한 노드를 가리키는 선택 포인터
    * 검색한 노드를 선택하고 삭제하는 용도로 사용
    * 2개의 포인터만 가짐
  
  * **검색을 수행하는 search 함수**
    * 검색에 사용되는 알고리즘은 선형 검색
    * 노드 스캔은 아래의 조건 중 하나만 성립하면 종료
      * 검색 조건을 만족하는 노드를 찾지 못하고 꼬리 노드를 지나가기 직전인 경우
      * 검색 조건을 만족하는 노드를 찾은 경우

  * **프리 리스트(free list)**
    * 삭제한 레코드를 관리하기 위해 사용하는 자료구조
    * 삭제한 레코드를 관리하면 사용하지 않은 빈 배열의 문제를 해결 가능
    * 노드 구조체 Node에 추가한 멤버
      * Dnext: 프리 리스트의 다음 포인터
    * 연결 리스트를 관리하는 구조체 List에 추가한 멤버
      * deleted: 프리 리스트의 머리 커서
      * max: 배열의 가장 꼬리 쪽에 들어 있는 노드의 레코드 번호
  
  * **이중 연결 리스트**
    * 선형 리스트의 단점인 앞쪽의 노드를 찾기 위해 비용이든다는 점을 개선한 자료구조
    * 각 노드에는 다음 노드와 앞쪽 노드에대한 포인터가 주어짐
   
    * **판단하는 방법**
      * 포인터가 머리 노드를 가리키는지 판단하는 식
        `p == list->head`
        `p->prev == NULL`
      * 포인터가 꼬리 노드를 가리키는지 판단하는 식
        `p->next == NULL`
        
   * **원형 리스트(circular list)**
     * 꼬리 노드가 머리 노드를 가리킴
     * 고리 모양으로 나열된 데이터를 저장할 때 알맞은 자료구조
     * 선형 리스트와의 차이점은 꼬리 노드의 다음 노드가 NULL이 아닌머리 노드의 포인터 값이라는 것
     * 선형 리스트에서 사용했던 자료형을 사용 가능
    
     * **판단하는 방법**
       * 빈 원형 리스트를 판단하는 식
         `list->head == NULL`
       * 노드가 1개인 원형 리스트를 판단하는 식
         `p->head->next == list->head`
       * 포인터가 머리 노드를 가리키는지 판단하는 식
         `p == list->head`
       * 포인터가 꼬리 노드를 가리키는지 판단하는 식
         `p->next == list->head`
         
  * **원형 이중 연결 리스트(circular doubly linked list)**
    * 앞에 두 개념을 합함
   
    * **노드를 나타내는 구조체 Dnode**
      * 이중 연결 리스트의 노드에서 사용
      * data: 데이터
      * prev: 앞쪽 노드에 대한 포인터
      * next: 다음 노드에 대한 포인터
    * **원형 이중 연결 리스트를 관리하는 구조체 Dlist**
      * 머리 노드와 선택한 노드에 대한 포인터를 가짐

## 11월 6일 강의

### qsort함수
  * 모든 자료형 배열에 적용 가능
  * qsort 함수의 4개 인수는 첫 번째 요소에 대한 포인터, 요소의 개수, 요소의 크기, 비교 함수에 대한 포인터
  * 비교 함수는 아래의 값을 반환하며 직접 작성
    * 첫 번째 인수가 가리키는 값이 더 작은 경우 음수값(-1)을 반환
    * 첫 번째 인수가 가리키는 값과 두 번째 인수가 가리키는 값이 같을 경우 0을 반환
    * 첫 번째 인수가 가리키는 값이 더 큰 경우 양숫값(1)을 반환
   
### 병합(merge)
  * **정렬이 끝난 배열이 조건**
  * 각 배열에서 선택한 요소의 값을 비교하여 작은 값의 요소를 꺼내 새로운 배열에 넣는 작업을 반복하여 정렬을 마치는 배열 생성
  * merge함수는 요소의 개수가 na개인 배열 a와 요소의 개수가 nb개인 배열 b를 병합하여 배열 c에 저장
  * 3개의 배열 a, b, c를 동시에 스캔
    * 배열이 선택한 요소의 인덱스는 pa, pb, pc
    * 인덱스를 저잘한 변수를 커서라고 함
  * 처음에는 커서를 모두 0으로 초기화

  * **병합 정렬**
    * 정렬을 마친 배열의 병합을 응용하여 분할 정복법에 따라 정렬하는 알고리즘
    * 먼저 배열을 앞과 뒤로 나눔
    * 나눈 두 배열을 각각 정렬하고 병합하면 배열 모두를 정렬할 수 있음

    * **병합 정렬 알고리즘**
      * 배열의 요소 개수가 2개 이상인 경우
        1. 배열의 앞부분을 병합 정렬로 정렬
        2. 배열의 뒷부분을 병합 정렬로 정렬
        3. 배열의 앞부분과 뒷부분을 병합  

* **힙(heap)**
  * 부모의 값이 자식의 값보다 항상 크다는 조건을 마족하는 완전 이진트리
  * 형제 사이의 대소관계는 일정하지 않음
  
  * **힙 정렬**
    * 가장 큰 값이 루트에 위치하는 특징을 이용하는 정렬 알고리즘
    * 다음 작업을 반복해 꺼낸 값을 늘어놓으면 정렬 종료
      * 힙에서 가장 큰 값인 루트를 꺼냄
      * 루트 이외의 부분을 힙으로 전환
    * 선택 정렬을 응용한 알고리즘
    * 힙에서 가장 큰 값인 루트를 꺼내고 남은 요소에서 다시 가장 큰 값을 구해야 함
   
    * **루트를 없애고 힙 상태 유지**
      * 루트를 없앤 후 다시 힙을 만들기 위해 요소를 알맞은 위치로 내려보내야 함
        1. 루트를 꺼냄
        2. 마지막 요소를 루트로 이동
        3. 자기보다 큰 값을 가지는 자식 요소와 자리를 바꾸며 아래쪽으로 내려가는 작업 반복 이때 자식의 값이 작거나 잎에 다다르면 작업 종료

* **도수 정렬**
  * 요소를 비교할 필요가 없음
 
  * **정렬 알고리즘**
    * 도수분포표 만들기
    * 누적도수분포표 만들기
    * 목적 배열 만들기
    * 배열 복사하기
   
![Image](https://github.com/user-attachments/assets/9b8d5b1b-87fc-4583-b4b5-f3ce151b24f7)

![Image](https://github.com/user-attachments/assets/17f02664-444e-4728-8f7d-9cb9c791025a)

## 10월 31일 강의

### 정렬

* **단순 선택 정렬(straight selection sort)**
  * 정렬하지 않은 부분에서 값이 가장 작은 요소를 선택한 후 정렬되지 않은 부분의 첫번째 요소와 교환
  * 과정
    * 가장 작은 키의 값 a[min]선택
    * a]min]과 정렬하지 않은 첫 번째 요소를 교환
   
* **단순 삽입 정렬(straight insertion sort)**
  * 선택 요소를 더 앞쪽의 알맞는 위치에 삽입하는 작업을 반복하여 정렬
  * 정렬되지 않은 부분의 첫 요소를 정렬된 부분의 알맞은 위치에 삽입
  * 아래의 두 조건 중 하나를 만족할 때까지 j를 1 감소시키면서 대입을 반복
    1. 정렬된 열의왼쪽 끝에 도달
    2. tmp보다 작거나 같은 키를 갖는 항목을 발견
  * 드모르간 법칙 적용을 적용해 두 조건이 모두 성립할 때까지 반복
    1. j가 0보다 큼
    2. a[j-1] 값이 tmp보다 큼
  * 특징
    * 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라짐
    * 삽입할 위치가 멀리 있으면 이동 횟수가 많아
    
* **셀 정렬(shell sort)**
  * 단순 삽입 정렬의 장점은 살리고 단점은 보완한 정렬 알고리즘
  * 배열의 요소를 그룹으로 나눠 그룹별로 단순 삽입 정렬을 실행
  * 그룹을 합치며 정렬을 반복해 요소의 이동 횟수를 줄임

* **4-정렬**
  * 4칸만큼 떨어진 요소를 모아 그룹을 4개로 나누어 정렬
  * 정렬을 마친 상태에 가까워짐
 
* **2-정렬**
  * 2칸만큼 떨어진 요소를 모아 2그룹으로 나누어 정렬

* **h-정렬**
  * 셀 정렬 과정에서 수행하는 각각의 정렬
    1. 2개 요소에 대해 4-정렬
    2. 4개 요소에 대해 2-정렬
    3. 8개 요소에 대해 1-정렬
  * 증분값(h값)의 선택
    * h값은 n부터 감소해 마지막에 1이 되면 됨
    * h값이 서로 배수가 되지 않게 해야 요소가 충분히 섞여 효율적임

* **퀵 정렬(quick sort)**
  * 일반적으로 사용되는 빠른 정렬 알고리즘
  * 각 그룹에 대해 피벗 설정과 그룹 나눔을 반복하여 모든 그룹이 1명이 되면 정렬 종료
  * 배열을 두 그룹으로 나누기
    * 피벗 이하의 요소를 배열 왼쪽, 이상의 요소를 배열 오른쪽으로 배치
    * 이때 동일한 요소를 교환하려는 시도가 있을 수 있는데 의미 없어 보여도 해당 시도는 1회이므로 해도 괜찮음

## 10월 30일 강의

### 큐(queue)

* 데이터를 일시적으로 쌓아 두기 위한 자료구조
* 선입선출 구조
   * 인큐(en-queue): 큐에 데이터 넣기
   * 디큐(de-queue): 데이터 꺼내기
   * 프런트(front): 데이터를 꺼내는 쪽
   * 리어(rear): 데이터를 넣는 쪽

### 링 버퍼(ring buffer)

* 배열의 처음과 끝이 연결되었다 보는 자료구조
   * 프런트(front): 논리적인 맨 처음 요소의 인덱스
   * 리어(rear): 논리적인 맨 끝 요소의 하나 뒤의 인덱스, 다음 요소를 인큐할 장소 미리 지정
* 인큐와 디큐를 수행함에따라 프런트와 리어의 값이 변화하여 배열요소를 앞으로 옮기지 않는 큐를 구현 가능
* 함수
   * Print: 큐의 모든 데이터를 순서대로 출력
   * Terminate: 할당된 배열을 해제

### 정렬(sorting)

* 항목의 대소 관계에 따라 순서를 바꾸는 작업(오름차순, 내림차순)
* 안정성: 요소의 순서가 정렬 전 후에도 유지되는 것
* 핵심요소: 교환, 선택, 삽입

* **버블정렬**
   * 패스(pass)
      * 이웃한 요소를 비교 교환하는 작업을 반복
      * 요소의 개수가 n개 면 n-1회 비교, 교환 종료시 가장 작은 요소가 처음으로 이동
  ```c
  '6'   '4'   '3'   '7'   '1'   '9'   '8'
  '6'   '4'   '3'   '7'   '1'   '8'   '9'
  '6'   '4'   '3'   '7'   '1'   '8'   '9'
  '6'   '4'   '3'   '1'   '7'   '8'   '9'
  '6'   '4'   '1'   '3'   '7'   '8'   '9'
  '6'   '1'   '4'   '3'   '7'   '8'   '9'
  '1'   '6'   '4'   '3'   '7'   '8'   '9'
  ```
   * 수행 횟수
      * 패스 1회 수행할때마다 정렬할 요소 1 감소
      * 모든 정렬이 끝나려면 n-1회의 패스가 수행
   * 정렬 알고리즘
      * 두 요소의 인덱스를 j-1와 j라고 가정
      * j의 시작값은 n-1
      * 한번의 패스에서 j값이 i+1이 될때까지 비교, 교환 수행
      * 비교 횟수는 n(n-1)/2회
      * 교환횟수의 평균값은 n(n-1)/4회
      * 이동횟수의 평균값은 3n(n-1)/4회
   * 알고리즘 개선
      * 정렬을 마친 상태라면 그 이후의 패스는 요소 교환 X
      * 어떤 패스에서 교환 횟수가 0이면 정렬 작업 멈춤
      * 어느 시점 이후 교환이 일어나지 않으면 정렬을 마친 상태라 생각

## 9월 11일 강의

## 9월 4일 강의

[문자 크기](#h1에-해당) / [리스트](#리스트) 


# h1에 해당
## h2에 해당
### h3에 해당
#### h4에 해당
##### h5에 해당
###### h6에 해당


*이탤릭 체*

**볼드 체**


# 리스트

* 언오더드 리스트
* 언
    * 탭
    * 탭
        * 탭
        * 탭
            * 변화없음

1. 오더드 리스트
2. 
3. 

# 크드 블럭

```c
# include <stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0
}
```
인라인 코드 블럭 예 : `<br>` 다른 예 : `ctrl` + `A`

# 외부링크
[구글로 가기](https://google.com "구글 링크")

![이미지](./image.jpg "이미지 삽입")
