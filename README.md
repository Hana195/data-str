# 김 은우
### 202530207

## 11월 20일 강의

### 트리
  * **트리 관련 용어**
    * 트리를 구성하는 요소는 노드와 가지
    * 각 노드는 가지를 통해 다른 노드와 연결
   
    * **루트(root)**
      * 트리의 가장 윗부분에 위치하는 노드
      * 하나의 트리에는 하나의 루트가 있음
     
    * **리프(leaf)**
      * 트리의 가장 아랫부분에 위치하는 노드
      * 가장 아랫부분의 의미는 더 이상 뻗어 나갈 수 없는 마지막에 노드가 위치해 있다는 의미

    * **안쪽 노드**
      * 루트를 포함하여 리프를 제외한 노드
     
    * **자식(child)**
      * 어떤 노드로부터 가지로 연결된 아래쪽 노드
      * 노드는 자식을 여러 개 가질 수 있음
     
    * **부모(parent)**
      * 어떤 노드에서 가지로 연결된 위쪽 노드
      * 노드는 1개의 부모를 가짐

    * **형제(sibling)**
      * 같은 부모를 가지는 노드

    * **조상(ancestor)**
      * 어떤 노드에서 가지로 연결된 위쪽 노드 전부
     
    * **자손(descendant)**
      * 어떤 노드에서 가지로 연결된 아래쪽 노드 전부
     
    * **레벨(level)**
      * 루트로부터 얼마나 떨어져 있는지에 대한 값
      * 루트의 레벨은 0, 루트로부터 가지가 하나씩 아래로 뻗어나갈때마다 레벨 1 증가
     
    * **차수(degree)**
      * 노드가 갖는 자식의 수
      * 모든 노드의 차수가 n 이하인 트리를 n진 트리라고 함
     
    * **높이(height)**
      * 루트부터 가장 멀리 떨어진 리프까지의 거리(리프 레벨의 최댓값)
     
    * **서브 트리(subtree)**
      * 트리 안에서 다시 어떤 노드를 루트로 정하고 그 자손으로 이루어진 트리
     
    * **널 트리(null tree)**
      * 노드, 가지가 없는 트리
     
  * **순서 트리의 탄색 방법**
    * **너비 우선 탐색(breadth-first Search)**
      * 낮은 레벨에서 시작해 왼쪽에서 오른쪽 방향으로 검색하고 한 레벨에서의 검색이 끝나면 다음 레벨로 내려감
     
    * **깊이 우선 탐색(depth-first Search)**
      * 리프까지 내려가면서 검색하는 것을 우선순위로 함
      * 리프에 도달해 더 이상 검색을 진행할 곳이 없는 경우 부모에게 돌아감
      * 다시 자식 노드로 내려감
     
      * 노드 방문 종류
        * 전위 순회
        * 중위 순회
        * 후위 순회

  * **이진트리(binary tree)**
    * 노드가 왼쪽 자식과 오른쪽 자식을 갖는 트리
    * 노드의 자식은 2명 이하만 유지
    * 왼쪽 자식과 오른쪽 자식을 구분함
    * 왼쪽 자식을 다시 루트로 하는 서브 트리를 *왼쪽 서브 트리*, 오른쪽 자식을 다시 루트로 하는 서브 트리를 *오른쪽 서브 트리*라고 함
   
    * **완전 이진 트리(completr binary tree)**
      * 루트부터 노드가 채워져 있으면서 같은 레벨에서는 왼쪽에서 오른쪽으로 노드가 채워져있는 트리
        1. 마지막 레벨을 제오한 레벨은 노드를 가득 채움
        2. 마지막 레벨은 왼쪽부터 오른쪽 방향으로 노드를 채우되 반드시 끝까지 채울 필요는 없음
      * 높이가 k인 완정 이진트리가 가질 수 있는 노드의 최댓값은 2^(k+1)-1개
      * n개의 노드를 저장할 수 있는 완전이진트리의 높이는 log n
      * 너비 우선 탐색을 하며 각 노드에 0, 1, 2, ...값을 주면 배열에 저장하는 인덱스와 일대일로 대응

  * **이진 검색 트리(binary Search tree)**
    * 이진트리가 다음의 조건을 만족
      1. 어떤 노드 n을 기준으로 왼쪽 서브 트리의 노드의 모든 키값은 노드 n의 키값보다 작아야 함
      2. 오른쪽 서브 트리 노드의 키값은 노드 n의 키값보다 커야 함
      3. 같은 키값을 갖는 노드는 없음
    * 이진검색트리의 특징
      * 구조가 단순함
      * 중위 순회를 하면 키값의 오름차순으로 노드를 얻을 수 있음
      * 이진검색과 비슷한 방식으로 빠르게 검색할 수 있음
      * 노드를 삽입하기 쉬움
     
    * **노드를 삭제하는 Remove 함수**
      * 노드를 삭제할 때는 세 가지 서로 다른 상황에 놓이기 때문에 각각의 상황에 맞게 처리
        
        * **자식 노드가 없는 노드를 삭제하는 경우**
          * 삭제할 노드가 부모 노드의 왼쪽 자식이면 부모의 왼쪽 포인터를 NULL로 함
          * 삭제할 노드가 부모 노드의 오른쪽 자식이면 부모의 오른쪽 포인터를 NULL로 함
            
        * **자식 노드가 1개인 노드를 삭제하는 경우**
          * 삭제 대상 노드가 부모 노드의 왼쪽 자식인 경우 부모의 왼쪽 포인터가 삭제 대상 노드의 자식을 가리키도록 함
          * 삭제 대상 노드가 부모 노드의 오른쪽 자식인 경우 부모의 오른쪽 포인터가 삭제 대상 노드의 자식을 가리키도록 함
         
        * **자식 노드가 2개 이상인 노드를 삭제하는 경우**
          1. 삭제할 노드의 왼쪽 서브 트리에서 키값이 가장 큰 노드를 검색
          2. 검색한 노드를 삭제 위치로 복사
          3. 옮긴 노드를 삭제
            * 옮긴 노드에 자식이 없으면 '자식 노드가 없는 노드를 삭제하는 경우'에 따라 노드를 삭제
            * 옮긴 노드에 자식이 1개만 있으면 '자식 노드가 1개인 노드를 삭제하는 경우'에 따라 노드를 삭제

### 해시법
  * **해시법(hashing)**
    * 나머지를 구하는 연산 또는 나머지 연산을 다시 응용한 연산을 사용
    * 해시 테이블의 각 요소를 *버킷*이라고 함
  
  * **충돌(collision)**
    * 저장하 버킷이 중복되는 현상
    * 키값과 해시값의 대응 관계가 반드시 1대1이라는 보증은 없음(보통 n대1)
   
    * **대처법**
      1. **체인법**: 같은 해시값을 갖는 요소를 연결 리스트로 관리
      2. **오픈 주소법**: 빈 버킷을 찾을 때까지 해시를 반복

    * **체인법(chaining)**
      * 해시값을갖는 데이터를 쇠사슬 모양으로 연결 리스트에서 연결하는 방법으로 오픈 해시법이라고도 함
     
      * **같은 해시값을 갖는 데이터 저장하기**
        * 배열의 각 버킷에 저장하는 값은 그 인덱스를 해시값으로 하는 연결 리스트의 첫 번째 노드에 대한 포인터

      * **버킷용 구조체 Node**
        * 개별 버킷의 자료형을 나타낸 것
          * data: 데이터
          * next: 다음 노드에 대한 포인터로 다음 노드가 존재하지 않을때는 NULL이 됨
         
      * **해시 테이블을 관리하는 구조체 ChainFash**
        * size: 해시 테이블의 크기
        * table: 해시 테이블을 저장하는 배열의 첫 번째 요소에 대한 포인터
        * 멤버 table은 해시 테이블을 저장하는 배열
        * 배열용 메모리 영역을 확보하는 작업은 initalize 함수가 수행
       
      * **해시 테이블을 초기화하는 initalize 함수**
        * 첫 번째 인수 h는 처리 대상인 해시 구조체 객체에 대한 포인터
        * 요소의 개수가 size인 배열 table의 본체를 생성하고 매개변수 size로 받은 값을 멤버 size에 복사

      * **키값으로 요소를 검색하는 Search 함수**
        * 키값이 x->no인 요소를 검색하는 함수
        1. 해시 함수가 키값을 해시값으로 변환
        2. 해시값을 인덱스로 하는 버킷을 선택
        3. 선택한 버킷의 연결 리스트를 처음부터 순서대로 검색
          * 키값과 같은 값을 찾으면 검색 성공
          * 끝까지 스캔하여 찾지 못하면 검색 실패

      * **요소를 추가하는 Add 함수**
        * 포인터 x가 가리키는 데이터를 추가하는 함수
        1. 해시 함수가 키값을 해시값으로 변환
        2. 해시값을 인덱슬 하는 버킷을 선택
        3. 버킥에 저장된 포인터가 가리키는 연결 리스트를 처음부터 순서대로 검색
          * 키값과 같은 값을 찾으면 키값이 이미 등록된 상태이므로 추가에 실패
          * 끝까지 스캔하여 찾지 못하면 리스트ㅡ이 맨 앞 위치에 노드를삽입
       
      * **요소를 삭제하는 Remove 함수**
        * 키값이 x->no인 요소를 삭제하는 함수
        1. 해시 함수가 키값을 해시값으로 변환
        2. 해시값을 인덱스로 하는 버킷을 선택
        3. 선택한 버킷의 연결 리스트를 처음부터 순서대로 검색
          * 키값과 같은 값을 찾으면 그 노드를 리스트에서 삭제
          * 그렇지 않으면 못하면 삭제 실패

## 11월 13일 강의

### 선형 리스트
  * **리스트(list)**
    * 데이터를 순서대호 나열해 놓은 자료구조
    * 가장 단순한 구조를 가진 리스트를 선형 리스트 또는 연결 리스트라고 함
    * 건너뛰어 데이터를 전달할 수 없음
  
  * **노드(node)**
    * 리스트의 각 요소
    * 각각의 노드는 데이터와 다음 노드를 가리키는 포인터를 가짐
    * 처음과 끝의 노드는 각각 머리 노드, 꼬리 노드라 표현
    * 하나ㅡ이 노드에 대해 바로 앞에 노드를 앞쪽 노드, 바로 뒤에 노드를 다음 노드라 함
  
    * **다음 노드 꺼내기**
      * 배열의 각 요소에는 순서대로 데이터가 저장
      * 다음 노드 꺼내기는 1만큼 큰 인덱스를 갖는 요소에 접근
  
    * **노드의 삽입과 삭제**
      * 삽입,삭제하는 경우 모든 요소를 밀거나 앞으로 당겨야 함
      * 배열로 구현한 선형 리스트는 데이터의 크기를 미리 알아야함
      * 데이터를 모두 옮겨야 하기 때문에 효율이 좋지 않음
  
  * **노드용 구조체 Node**
    * 연결 리스트에 데이터를 삽입할 때 만들고 삭제할 때 없애면 데이터를 밀고 당기는 문제 해결 가능
    * 두 멤버 data와 next로 구성
      * data: 데이터
      * next: 다음 노드에 대한 포인터
    * 자기 자신과 같은 자료형의 댇체를 가리키는 데이터가 내부에 포함
    * 이러한 자료구조를 **자기 참조형**이라고 함
     
  * **연결 리스트를 관리하는 구조체 List**
    * 노드형 구조체를 사용한 연결 리스트
    * 두 멤버로 구성되어 있고 Node에 대한 포인터 자료형을 가짐
    * head는 연결 리스트의 머리 노드를 가리키는 머리 포인터이고, crnt는 현재 선택한 노드를 가리키는 선택 포인터
    * 검색한 노드를 선택하고 삭제하는 용도로 사용
    * 2개의 포인터만 가짐
  
  * **검색을 수행하는 search 함수**
    * 검색에 사용되는 알고리즘은 선형 검색
    * 노드 스캔은 아래의 조건 중 하나만 성립하면 종료
      * 검색 조건을 만족하는 노드를 찾지 못하고 꼬리 노드를 지나가기 직전인 경우
      * 검색 조건을 만족하는 노드를 찾은 경우

  * **프리 리스트(free list)**
    * 삭제한 레코드를 관리하기 위해 사용하는 자료구조
    * 삭제한 레코드를 관리하면 사용하지 않은 빈 배열의 문제를 해결 가능
    * 노드 구조체 Node에 추가한 멤버
      * Dnext: 프리 리스트의 다음 포인터
    * 연결 리스트를 관리하는 구조체 List에 추가한 멤버
      * deleted: 프리 리스트의 머리 커서
      * max: 배열의 가장 꼬리 쪽에 들어 있는 노드의 레코드 번호
  
  * **이중 연결 리스트**
    * 선형 리스트의 단점인 앞쪽의 노드를 찾기 위해 비용이든다는 점을 개선한 자료구조
    * 각 노드에는 다음 노드와 앞쪽 노드에대한 포인터가 주어짐
   
    * **판단하는 방법**
      * 포인터가 머리 노드를 가리키는지 판단하는 식
        `p == list->head`
        `p->prev == NULL`
      * 포인터가 꼬리 노드를 가리키는지 판단하는 식
        `p->next == NULL`
        
   * **원형 리스트(circular list)**
     * 꼬리 노드가 머리 노드를 가리킴
     * 고리 모양으로 나열된 데이터를 저장할 때 알맞은 자료구조
     * 선형 리스트와의 차이점은 꼬리 노드의 다음 노드가 NULL이 아닌머리 노드의 포인터 값이라는 것
     * 선형 리스트에서 사용했던 자료형을 사용 가능
    
     * **판단하는 방법**
       * 빈 원형 리스트를 판단하는 식
         `list->head == NULL`
       * 노드가 1개인 원형 리스트를 판단하는 식
         `p->head->next == list->head`
       * 포인터가 머리 노드를 가리키는지 판단하는 식
         `p == list->head`
       * 포인터가 꼬리 노드를 가리키는지 판단하는 식
         `p->next == list->head`
         
  * **원형 이중 연결 리스트(circular doubly linked list)**
    * 앞에 두 개념을 합함
   
    * **노드를 나타내는 구조체 Dnode**
      * 이중 연결 리스트의 노드에서 사용
      * data: 데이터
      * prev: 앞쪽 노드에 대한 포인터
      * next: 다음 노드에 대한 포인터
      * 
    * **원형 이중 연결 리스트를 관리하는 구조체 Dlist**
      * 머리 노드와 선택한 노드에 대한 포인터를 가짐
        
    * **노드를 생성하는 AlloDnode 함수**
      * Dnode형 객체를 생성하고 해당 객체의 포인터를 반환하는 함수
        
    * **노드의 멤버값을 설정하는 SetDnode 함수**
      * Dnode형 객체의 멤버값을 설정
      * 첫번째 배개변수 n에 전달받은 Dnode형 객체 포인트를 총해 멤버값을 설정
      * 객체 멤버인 data, prev, next에 두 번째 매개변수가 가리키는 객체의 값, 세 번째 매개변수와 네 번째 매개변수의 포인터값을 대입
        
    * **원형 이중 연결 리스트를 초기화하는 initialize 함수**
      * 비어 있는 상태의 원형 이중 연결 리스트를 만드는 함수
      * 리스트의 머리 부분에 더미 노드가 생성
      * 3개 포인터가 가리키는 대상 모두를 리스트의 앞쪽에 있는 더미라 함
        * 머리 포인터 list->head가 가리키는 대상
        * 더미 노드의 앞쪽 포인터 list->head->prev가 가리키는 대상
        * 더미 노드의 다음 포인터 list->head->next가 가리키는 대상
          
    * **리스트가 비어 있는지 검사하는 IsEmpty 함수**
      * 더미 노드의 뒤쪽 포인터 list->head->next가 자신의 더미 노드인 list->head를 가리키는지 판단
     
    * **선택한 노드의 데이터를 출력하는 PrintCurrent/PrintLnCurrent 함수**
      * PrintCurrent 함수는 list->crnt가 가리키는 노드의 테이터를 다른 함수를 이용해 출력
      * PrintLnCurrent 함수는 출력한 후의 개행 문자를 출력

    * **바로 다음에 노드를 삽입하는 InsertAfter 함수**
      * 포인터 p가 가리키는 노드의 바로 다음에 노드를 삽입
     
    * **노드를 삭제하는 Remove 함수**
      * 포인터 p가 가리키는 노드를 삭제하는 함수
     
    * **선택한 노드를 삭제하는 RemoveCurrent 함수**
      * Remove 함수를 사용해 포인터 list->crnt가 가리키는 노드를 삭제

    * **모든 노드를 삭제하는 Clear 함수**
      * 더미 노드를 제이하고 모든 노드를 삭제하는 함수
      * 리스트가 빌 때까지 RemoveFront 함수를 사용해 머리 노드의 삭제를 반복
      * 선택한 포인터 list->crnt가 가리키는 노드는 더미 노드 list->head로 업데이트

    * **원형 이중 연결 리스트를 종료하는 Terminate 함수**
      * 먼저 Clear 함수를 호출해 모든 노드를 삭제하고 더미 노드의 메모리 영역도 해제

## 11월 6일 강의

### qsort함수
  * 모든 자료형 배열에 적용 가능
  * qsort 함수의 4개 인수는 첫 번째 요소에 대한 포인터, 요소의 개수, 요소의 크기, 비교 함수에 대한 포인터
  * 비교 함수는 아래의 값을 반환하며 직접 작성
    * 첫 번째 인수가 가리키는 값이 더 작은 경우 음수값(-1)을 반환
    * 첫 번째 인수가 가리키는 값과 두 번째 인수가 가리키는 값이 같을 경우 0을 반환
    * 첫 번째 인수가 가리키는 값이 더 큰 경우 양숫값(1)을 반환
   
### 병합(merge)
  * **정렬이 끝난 배열이 조건**
  * 각 배열에서 선택한 요소의 값을 비교하여 작은 값의 요소를 꺼내 새로운 배열에 넣는 작업을 반복하여 정렬을 마치는 배열 생성
  * merge함수는 요소의 개수가 na개인 배열 a와 요소의 개수가 nb개인 배열 b를 병합하여 배열 c에 저장
  * 3개의 배열 a, b, c를 동시에 스캔
    * 배열이 선택한 요소의 인덱스는 pa, pb, pc
    * 인덱스를 저잘한 변수를 커서라고 함
  * 처음에는 커서를 모두 0으로 초기화

  * **병합 정렬**
    * 정렬을 마친 배열의 병합을 응용하여 분할 정복법에 따라 정렬하는 알고리즘
    * 먼저 배열을 앞과 뒤로 나눔
    * 나눈 두 배열을 각각 정렬하고 병합하면 배열 모두를 정렬할 수 있음

    * **병합 정렬 알고리즘**
      * 배열의 요소 개수가 2개 이상인 경우
        1. 배열의 앞부분을 병합 정렬로 정렬
        2. 배열의 뒷부분을 병합 정렬로 정렬
        3. 배열의 앞부분과 뒷부분을 병합  

* **힙(heap)**
  * 부모의 값이 자식의 값보다 항상 크다는 조건을 마족하는 완전 이진트리
  * 형제 사이의 대소관계는 일정하지 않음
  
  * **힙 정렬**
    * 가장 큰 값이 루트에 위치하는 특징을 이용하는 정렬 알고리즘
    * 다음 작업을 반복해 꺼낸 값을 늘어놓으면 정렬 종료
      * 힙에서 가장 큰 값인 루트를 꺼냄
      * 루트 이외의 부분을 힙으로 전환
    * 선택 정렬을 응용한 알고리즘
    * 힙에서 가장 큰 값인 루트를 꺼내고 남은 요소에서 다시 가장 큰 값을 구해야 함
   
    * **루트를 없애고 힙 상태 유지**
      * 루트를 없앤 후 다시 힙을 만들기 위해 요소를 알맞은 위치로 내려보내야 함
        1. 루트를 꺼냄
        2. 마지막 요소를 루트로 이동
        3. 자기보다 큰 값을 가지는 자식 요소와 자리를 바꾸며 아래쪽으로 내려가는 작업 반복 이때 자식의 값이 작거나 잎에 다다르면 작업 종료

* **도수 정렬**
  * 요소를 비교할 필요가 없음
 
  * **정렬 알고리즘**
    * 도수분포표 만들기
    * 누적도수분포표 만들기
    * 목적 배열 만들기
    * 배열 복사하기
   
![Image](https://github.com/user-attachments/assets/9b8d5b1b-87fc-4583-b4b5-f3ce151b24f7)

![Image](https://github.com/user-attachments/assets/17f02664-444e-4728-8f7d-9cb9c791025a)

## 10월 31일 강의

### 정렬

* **단순 선택 정렬(straight selection sort)**
  * 정렬하지 않은 부분에서 값이 가장 작은 요소를 선택한 후 정렬되지 않은 부분의 첫번째 요소와 교환
  * 과정
    * 가장 작은 키의 값 a[min]선택
    * a]min]과 정렬하지 않은 첫 번째 요소를 교환
   
* **단순 삽입 정렬(straight insertion sort)**
  * 선택 요소를 더 앞쪽의 알맞는 위치에 삽입하는 작업을 반복하여 정렬
  * 정렬되지 않은 부분의 첫 요소를 정렬된 부분의 알맞은 위치에 삽입
  * 아래의 두 조건 중 하나를 만족할 때까지 j를 1 감소시키면서 대입을 반복
    1. 정렬된 열의왼쪽 끝에 도달
    2. tmp보다 작거나 같은 키를 갖는 항목을 발견
  * 드모르간 법칙 적용을 적용해 두 조건이 모두 성립할 때까지 반복
    1. j가 0보다 큼
    2. a[j-1] 값이 tmp보다 큼
  * 특징
    * 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라짐
    * 삽입할 위치가 멀리 있으면 이동 횟수가 많아
    
* **셀 정렬(shell sort)**
  * 단순 삽입 정렬의 장점은 살리고 단점은 보완한 정렬 알고리즘
  * 배열의 요소를 그룹으로 나눠 그룹별로 단순 삽입 정렬을 실행
  * 그룹을 합치며 정렬을 반복해 요소의 이동 횟수를 줄임

* **4-정렬**
  * 4칸만큼 떨어진 요소를 모아 그룹을 4개로 나누어 정렬
  * 정렬을 마친 상태에 가까워짐
 
* **2-정렬**
  * 2칸만큼 떨어진 요소를 모아 2그룹으로 나누어 정렬

* **h-정렬**
  * 셀 정렬 과정에서 수행하는 각각의 정렬
    1. 2개 요소에 대해 4-정렬
    2. 4개 요소에 대해 2-정렬
    3. 8개 요소에 대해 1-정렬
  * 증분값(h값)의 선택
    * h값은 n부터 감소해 마지막에 1이 되면 됨
    * h값이 서로 배수가 되지 않게 해야 요소가 충분히 섞여 효율적임

* **퀵 정렬(quick sort)**
  * 일반적으로 사용되는 빠른 정렬 알고리즘
  * 각 그룹에 대해 피벗 설정과 그룹 나눔을 반복하여 모든 그룹이 1명이 되면 정렬 종료
  * 배열을 두 그룹으로 나누기
    * 피벗 이하의 요소를 배열 왼쪽, 이상의 요소를 배열 오른쪽으로 배치
    * 이때 동일한 요소를 교환하려는 시도가 있을 수 있는데 의미 없어 보여도 해당 시도는 1회이므로 해도 괜찮음

## 10월 30일 강의

### 큐(queue)

* 데이터를 일시적으로 쌓아 두기 위한 자료구조
* 선입선출 구조
   * 인큐(en-queue): 큐에 데이터 넣기
   * 디큐(de-queue): 데이터 꺼내기
   * 프런트(front): 데이터를 꺼내는 쪽
   * 리어(rear): 데이터를 넣는 쪽

### 링 버퍼(ring buffer)

* 배열의 처음과 끝이 연결되었다 보는 자료구조
   * 프런트(front): 논리적인 맨 처음 요소의 인덱스
   * 리어(rear): 논리적인 맨 끝 요소의 하나 뒤의 인덱스, 다음 요소를 인큐할 장소 미리 지정
* 인큐와 디큐를 수행함에따라 프런트와 리어의 값이 변화하여 배열요소를 앞으로 옮기지 않는 큐를 구현 가능
* 함수
   * Print: 큐의 모든 데이터를 순서대로 출력
   * Terminate: 할당된 배열을 해제

### 정렬(sorting)

* 항목의 대소 관계에 따라 순서를 바꾸는 작업(오름차순, 내림차순)
* 안정성: 요소의 순서가 정렬 전 후에도 유지되는 것
* 핵심요소: 교환, 선택, 삽입

* **버블정렬**
   * 패스(pass)
      * 이웃한 요소를 비교 교환하는 작업을 반복
      * 요소의 개수가 n개 면 n-1회 비교, 교환 종료시 가장 작은 요소가 처음으로 이동
  ```c
  '6'   '4'   '3'   '7'   '1'   '9'   '8'
  '6'   '4'   '3'   '7'   '1'   '8'   '9'
  '6'   '4'   '3'   '7'   '1'   '8'   '9'
  '6'   '4'   '3'   '1'   '7'   '8'   '9'
  '6'   '4'   '1'   '3'   '7'   '8'   '9'
  '6'   '1'   '4'   '3'   '7'   '8'   '9'
  '1'   '6'   '4'   '3'   '7'   '8'   '9'
  ```
   * 수행 횟수
      * 패스 1회 수행할때마다 정렬할 요소 1 감소
      * 모든 정렬이 끝나려면 n-1회의 패스가 수행
   * 정렬 알고리즘
      * 두 요소의 인덱스를 j-1와 j라고 가정
      * j의 시작값은 n-1
      * 한번의 패스에서 j값이 i+1이 될때까지 비교, 교환 수행
      * 비교 횟수는 n(n-1)/2회
      * 교환횟수의 평균값은 n(n-1)/4회
      * 이동횟수의 평균값은 3n(n-1)/4회
   * 알고리즘 개선
      * 정렬을 마친 상태라면 그 이후의 패스는 요소 교환 X
      * 어떤 패스에서 교환 횟수가 0이면 정렬 작업 멈춤
      * 어느 시점 이후 교환이 일어나지 않으면 정렬을 마친 상태라 생각

## 9월 11일 강의

## 9월 4일 강의

[문자 크기](#h1에-해당) / [리스트](#리스트) 


# h1에 해당
## h2에 해당
### h3에 해당
#### h4에 해당
##### h5에 해당
###### h6에 해당


*이탤릭 체*

**볼드 체**


# 리스트

* 언오더드 리스트
* 언
    * 탭
    * 탭
        * 탭
        * 탭
            * 변화없음

1. 오더드 리스트
2. 
3. 

# 크드 블럭

```c
# include <stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0
}
```
인라인 코드 블럭 예 : `<br>` 다른 예 : `ctrl` + `A`

# 외부링크
[구글로 가기](https://google.com "구글 링크")

![이미지](./image.jpg "이미지 삽입")
