# 김 은우
### 202530207

## 11월 6일 강의

### qsort함수
  * 모든 자료형 배열에 적용 가능
  * qsort 함수의 4개 인수는 첫 번째 요소에 대한 포인터, 요소의 개수, 요소의 크기, 비교 함수에 대한 포인터
  * 비교 함수는 아래의 값을 반환하며 직접 작성
    * 첫 번째 인수가 가리키는 값이 더 작은 경우 음수값(-1)을 반환
    * 첫 번째 인수가 가리키는 값과 두 번째 인수가 가리키는 값이 같을 경우 0을 반환
    * 첫 번째 인수가 가리키는 값이 더 큰 경우 양숫값(1)을 반환

## 10월 31일 강의

### 정렬

* 단순 선택 정렬(straight selection sort)
  * 정렬하지 않은 부분에서 값이 가장 작은 요소를 선택한 후 정렬되지 않은 부분의 첫번째 요소와 교환
  * 과정
    * 가장 작은 키의 값 a[min]선택
    * a]min]과 정렬하지 않은 첫 번째 요소를 교환
   
* 단순 삽입 정렬(straight insertion sort)
  * 선택 요소를 더 앞쪽의 알맞는 위치에 삽입하는 작업을 반복하여 정렬
  * 정렬되지 않은 부분의 첫 요소를 정렬된 부분의 알맞은 위치에 삽입
  * 아래의 두 조건 중 하나를 만족할 때까지 j를 1 감소시키면서 대입을 반복
    1. 정렬된 열의왼쪽 끝에 도달
    2. tmp보다 작거나 같은 키를 갖는 항목을 발견
  * 드모르간 법칙 적용을 적용해 두 조건이 모두 성립할 때까지 반복
    1. j가 0보다 큼
    2. a[j-1] 값이 tmp보다 큼
  * 특징
    * 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라짐
    * 삽입할 위치가 멀리 있으면 이동 횟수가 많아
    
* 셀 정렬(shell sort)
  * 단순 삽입 정렬의 장점은 살리고 단점은 보완한 정렬 알고리즘
  * 배열의 요소를 그룹으로 나눠 그룹별로 단순 삽입 정렬을 실행
  * 그룹을 합치며 정렬을 반복해 요소의 이동 횟수를 줄임

* 4-정렬
  * 4칸만큼 떨어진 요소를 모아 그룹을 4개로 나누어 정렬
  * 정렬을 마친 상태에 가까워짐
 
* 2-정렬
  * 2칸만큼 떨어진 요소를 모아 2그룹으로 나누어 정렬

* h-정렬
  * 셀 정렬 과정에서 수행하는 각각의 정렬
    1. 2개 요소에 대해 4-정렬
    2. 4개 요소에 대해 2-정렬
    3. 8개 요소에 대해 1-정렬
  * 증분값(h값)의 선택
    * h값은 n부터 감소해 마지막에 1이 되면 됨
    * h값이 서로 배수가 되지 않게 해야 요소가 충분히 섞여 효율적임

* 퀵 정렬(quick sort)
  * 일반적으로 사용되는 빠른 정렬 알고리즘
  * 각 그룹에 대해 피벗 설정과 그룹 나눔을 반복하여 모든 그룹이 1명이 되면 정렬 종료
  * 배열을 두 그룹으로 나누기
    * 피벗 이하의 요소를 배열 왼쪽, 이상의 요소를 배열 오른쪽으로 배치
    * 이때 동일한 요소를 교환하려는 시도가 있을 수 있는데 의미 없어 보여도 해당 시도는 1회이므로 해도 괜찮음

## 10월 30일 강의

### 큐(queue)

* 데이터를 일시적으로 쌓아 두기 위한 자료구조
* 선입선출 구조
   * 인큐(en-queue): 큐에 데이터 넣기
   * 디큐(de-queue): 데이터 꺼내기
   * 프런트(front): 데이터를 꺼내는 쪽
   * 리어(rear): 데이터를 넣는 쪽

### 링 버퍼(ring buffer)

* 배열의 처음과 끝이 연결되었다 보는 자료구조
   * 프런트(front): 논리적인 맨 처음 요소의 인덱스
   * 리어(rear): 논리적인 맨 끝 요소의 하나 뒤의 인덱스, 다음 요소를 인큐할 장소 미리 지정
* 인큐와 디큐를 수행함에따라 프런트와 리어의 값이 변화하여 배열요소를 앞으로 옮기지 않는 큐를 구현 가능
* 함수
   * Print: 큐의 모든 데이터를 순서대로 출력
   * Terminate: 할당된 배열을 해제

### 정렬(sorting)

* 항목의 대소 관계에 따라 순서를 바꾸는 작업(오름차순, 내림차순)
* 안정성: 요소의 순서가 정렬 전 후에도 유지되는 것
* 핵심요소: 교환, 선택, 삽입

* 버블정렬
   * 패스(pass)
      * 이웃한 요소를 비교 교환하는 작업을 반복
      * 요소의 개수가 n개 면 n-1회 비교, 교환 종료시 가장 작은 요소가 처음으로 이동
  ```c
  '6'   '4'   '3'   '7'   '1'   '9'   '8'
  '6'   '4'   '3'   '7'   '1'   '8'   '9'
  '6'   '4'   '3'   '7'   '1'   '8'   '9'
  '6'   '4'   '3'   '1'   '7'   '8'   '9'
  '6'   '4'   '1'   '3'   '7'   '8'   '9'
  '6'   '1'   '4'   '3'   '7'   '8'   '9'
  '1'   '6'   '4'   '3'   '7'   '8'   '9'
  ```
   * 수행 횟수
      * 패스 1회 수행할때마다 정렬할 요소 1 감소
      * 모든 정렬이 끝나려면 n-1회의 패스가 수행
   * 정렬 알고리즘
      * 두 요소의 인덱스를 j-1와 j라고 가정
      * j의 시작값은 n-1
      * 한번의 패스에서 j값이 i+1이 될때까지 비교, 교환 수행
      * 비교 횟수는 n(n-1)/2회
      * 교환횟수의 평균값은 n(n-1)/4회
      * 이동횟수의 평균값은 3n(n-1)/4회
   * 알고리즘 개선
      * 정렬을 마친 상태라면 그 이후의 패스는 요소 교환 X
      * 어떤 패스에서 교환 횟수가 0이면 정렬 작업 멈춤
      * 어느 시점 이후 교환이 일어나지 않으면 정렬을 마친 상태라 생각

## 9월 11일 강의

## 9월 4일 강의

[문자 크기](#h1에-해당) / [리스트](#리스트) 


# h1에 해당
## h2에 해당
### h3에 해당
#### h4에 해당
##### h5에 해당
###### h6에 해당


*이탤릭 체*

**볼드 체**


# 리스트

* 언오더드 리스트
* 언
    * 탭
    * 탭
        * 탭
        * 탭
            * 변화없음

1. 오더드 리스트
2. 
3. 

# 크드 블럭

```c
# include <stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0
}
```
인라인 코드 블럭 예 : `<br>` 다른 예 : `ctrl` + `A`

# 외부링크
[구글로 가기](https://google.com "구글 링크")

![이미지](./image.jpg "이미지 삽입")
