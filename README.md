# 김 은우
### 202530207

## 10월 30일 강의

### 큐(queue)

* 데이터를 일시적으로 쌓아 두기 위한 자료구조
* 선입선출 구조
   * 인큐(en-queue): 큐에 데이터 넣기
   * 디큐(de-queue): 데이터 꺼내기
   * 프런트(front): 데이터를 꺼내는 쪽
   * 리어(rear): 데이터를 넣는 쪽

### 링 버퍼(ring buffer)

* 배열의 처음과 끝이 연결되었다 보는 자료구조
   * 프런트(front): 논리적인 맨 처음 요소의 인덱스
   * 리어(rear): 논리적인 맨 끝 요소의 하나 뒤의 인덱스, 다음 요소를 인큐할 장소 미리 지정
* 인큐와 디큐를 수행함에따라 프런트와 리어의 값이 변화하여 배열요소를 앞으로 옮기지 않는 큐를 구현 가능
* 함수
   * Print: 큐의 모든 데이터를 순서대로 출력
   * Terminate: 할당된 배열을 해제

### 정렬(sorting)

* 항목의 대소 관계에 따라 순서를 바꾸는 작업(오름차순, 내림차순)
* 안정성: 요소의 순서가 정렬 전 후에도 유지되는 것
* 핵심요소: 교환, 선택, 삽입

* 버블정렬
   * 패스(pass)
      * 이웃한 요소를 비교 교환하는 작업을 반복
      * 요소의 개수가 n개 면 n-1회 비교, 교환 종료시 가장 작은 요소가 처음으로 이동
```c
'6'   '4'   '3'   '7'   '1'   '9'   '8'
'6'   '4'   '3'   '7'   '1'   '8'   '9'
'6'   '4'   '3'   '7'   '1'   '8'   '9'
'6'   '4'   '3'   '1'   '7'   '8'   '9'
'6'   '4'   '1'   '3'   '7'   '8'   '9'
'6'   '1'   '4'   '3'   '7'   '8'   '9'
'1'   '6'   '4'   '3'   '7'   '8'   '9'
```
   * 수행 횟수
      * 패스 1회 수행할때마다 정렬할 요소 1 감소
      * 모든 정렬이 끝나려면 n-1회의 패스가 수행
   * 정렬 알고리즘
      * 두 요소의 인덱스를 j-1와 j라고 가정
      * j의 시작값은 n-1
      * 한번의 패스에서 j값이 i+1이 될때까지 비교, 교환 수행
      * 비교 횟수는 n(n-1)/2회
      * 교환횟수의 평균값은 n(n-1)/4회
      * 이동횟수의 평균값은 3n(n-1)/4회
   * 알고리즘 개선
      * 정렬을 마친 상태라면 그 이후의 패스는 요소 교환 X
      * 어떤 패스에서 교환 횟수가 0이면 정렬 작업 멈춤
      * 어느 시점 이후 ㄱ환이 일어나지 않으면 정렬을 마친 상태라 생각

## 9월 11일 강의

## 9월 4일 강의

[문자 크기](#h1에-해당) / [리스트](#리스트) 


# h1에 해당
## h2에 해당
### h3에 해당
#### h4에 해당
##### h5에 해당
###### h6에 해당


*이탤릭 체*

**볼드 체**


# 리스트

* 언오더드 리스트
* 언
    * 탭
    * 탭
        * 탭
        * 탭
            * 변화없음

1. 오더드 리스트
2. 
3. 

# 크드 블럭

```c
# include <stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0
}
```
인라인 코드 블럭 예 : `<br>` 다른 예 : `ctrl` + `A`

# 외부링크
[구글로 가기](https://google.com "구글 링크")

![이미지](./image.jpg "이미지 삽입")
